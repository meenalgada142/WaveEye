import os
import csv
import json
import argparse
import pandas as pd
import re


def normalize(name):
    name = name.split('.')[-1]                     # strip hierarchy
    name = re.sub(r"\[.*?\]", "", name)            # strip array indexing
    name = re.sub(r"[^a-zA-Z0-9]", "", name)       # keep only letters/numbers
    return name.lower()


def load_metadata(path):
    """Load either CSV or JSON metadata."""
    if path.lower().endswith(".csv"):
        return load_metadata_csv(path)
    elif path.lower().endswith(".json"):
        return load_metadata_json(path)
    else:
        raise ValueError("Expected metadata as CSV or JSON")


def load_metadata_csv(path):
    with open(path, newline='') as f:
        next(f)
        reader = csv.DictReader(f)
        headers = reader.fieldnames
        signal_col = next(h for h in headers if "signal" in h.lower())
        class_col = next(h for h in headers if "class" in h.lower())

        mapping = {}
        clock_signals = []

        for row in reader:
            sig = row[signal_col].strip()
            cls = row[class_col].strip()
            mapping[sig] = cls
            if cls.lower() == "clock":
                clock_signals.append(sig)

        return mapping, clock_signals


def load_metadata_json(path):
    with open(path) as f:
        data = json.load(f)
    mapping = data.get("signals", {})
    clock_signals = [s for s, c in mapping.items() if c.lower() == "clock"]
    return mapping, clock_signals


def load_waveform(path):
    with open(path, newline='') as f:
        return list(csv.DictReader(f))


def match_waveform_signals(waveform_row, metadata_map):
    mapping = {}
    meta_norm = {normalize(k): k for k in metadata_map}

    for wf_sig in waveform_row.keys():
        cleaned = normalize(wf_sig)
        if cleaned in meta_norm:
            mapping[wf_sig] = meta_norm[cleaned]

    return mapping


def build_table(metadata_map, clock_signals, waveform, output_path):
    signal_map = match_waveform_signals(waveform[0], metadata_map)

    clock_column = None
    for wf_sig, meta_sig in signal_map.items():
        if meta_sig in clock_signals:
            clock_column = meta_sig
            break

    rows = []
    for row in waveform:

        # --- FIX: auto-detect time column (time_ps / time_ns / time_us) ---
        time_col = next(c for c in row.keys() if c.startswith("time_"))
        e = {time_col: row[time_col]}
        # ------------------------------------------------------------------

        # insert clock
        if clock_column:
            wf_sig = next((k for k, v in signal_map.items() if v == clock_column), None)
            e[clock_column] = row.get(wf_sig, "")

        # insert all other metadata signals
        for meta_sig in metadata_map:
            if meta_sig == clock_column:
                continue
            wf_sig = next((k for k, v in signal_map.items() if v == meta_sig), None)
            e[meta_sig] = row.get(wf_sig, "")

        rows.append(e)

    df = pd.DataFrame(rows)

    # FIX: use detected time column instead of hardcoded "time_ps"
    ordered = [time_col]
    if clock_column:
        ordered.append(clock_column)
    ordered += [s for s in metadata_map if s not in ordered]

    df = df[ordered]

    # FIX: class row uses the detected time column
    class_row = []
    for col in df.columns:
        if col == time_col:
            class_row.append("")
        elif col == clock_column:
            class_row.append("clock")
        else:
            class_row.append(metadata_map.get(col, "other"))

    with open(output_path, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(class_row)
        w.writerow(df.columns.tolist())
        w.writerows(df.values.tolist())

    print(f"Saved grouped signal CSV -> {output_path}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Map waveform values to RTL signals")
    parser.add_argument("metadata_file", help="Path to signals.json or signals.csv")
    parser.add_argument("waveform_csv", help="Waveform CSV generated by VCD converter")
    parser.add_argument("output_csv", help="Output wrapper CSV path")
    args = parser.parse_args()

    metadata_map, clock_signals = load_metadata(args.metadata_file)
    waveform = load_waveform(args.waveform_csv)

    build_table(metadata_map, clock_signals, waveform, args.output_csv)
